//
//  iCityAppDelegate.h
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import <UIKit/UIKit.h>
#import "FBConnect.h"

@interface iCityAppDelegate : UIResponder <UIApplicationDelegate>

@property (strong, nonatomic) UIWindow *window;

@property (nonatomic, strong) Facebook	*facebook;

@end


-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityAppDelegate.m
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import "iCityAppDelegate.h"
#define APP_ID @"310977542370966"

@implementation iCityAppDelegate

@synthesize facebook, window;

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Override point for customization after application launch.
    
    
    facebook = [[Facebook alloc] initWithAppId:APP_ID andDelegate:nil];
    
    
    return YES;
}

- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {
    
    return [facebook handleOpenURL:url];
}
							
- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}

@end



-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityTableViewConroller.h
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import <UIKit/UIKit.h>

@interface iCityTableViewConroller : UITableViewController

@property(nonatomic, strong) NSDictionary *cityDictionary;
@property(nonatomic, strong) NSArray *cityList;
@property(nonatomic, strong) NSArray *citySearchList;


@end

-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityTableViewConroller.m
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import "iCityTableViewConroller.h"
#import "iCityShowCityInfo.h"
#import "iCityAppDelegate.h"
#import "iCityFriendDetails.h"


#define CITY_LIST_URL @"http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20geo.counties%20where%20place%3D%22IN%22%20order%20by%20name&format=json"

#define WEATHER_URL @"http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%3D00000000&format=json"

#define LOCATION_URL @"http://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20geo.placefinder%20where%20woeid%3D00000000&format=json"

#define GOOGLE_API @"https://ajax.googleapis.com/ajax/services/search/web?v=1.0&q="

#define LOCATION_DATA  @"locationData"
#define FRIEND_DATA    @"friendArrayData"
#define LATITUDE       @"latitude"
#define LONGITUDE      @"longitude"
#define CITY_PIC       @"city_pic"
#define CITY_ID        @"city_id"
#define FRIEND_NAME    @"name"
#define FRIEND_CITY    @"subtitle"
#define PROFILE_IMAGE  @"profile_image"
#define CITY_PIC       @"city_pic"

#define FETCHING_FRIENDS 0
#define FETCHING_CITIES 1

#define AVERAGE_FRIENDS 10


@interface iCityTableViewConroller () <FBSessionDelegate, FBRequestDelegate>
{
    int currentAction;
}

@property (strong, nonatomic) NSMutableArray *tableData;
@property (strong, nonatomic) NSMutableArray *tableDataSections;
@property (strong, nonatomic) UINavigationController *navController;

@property (strong, nonatomic) NSMutableDictionary *cityToFriendMappingG;

@property (strong, nonatomic) NSMutableArray *cityFriendDictionaryArrayG;

@end

@implementation iCityTableViewConroller

@synthesize cityDictionary, cityList, tableData, tableDataSections, navController, cityFriendDictionaryArrayG, cityToFriendMappingG, citySearchList;

- (void)filterContentForSearchText:(NSString*)searchText scope:(NSString*)scope
{
    NSPredicate *resultPredicate = [NSPredicate
                                    predicateWithFormat:@"SELF contains[c] %@",
                                    searchText];
    
    self.citySearchList = [self.cityList filteredArrayUsingPredicate:resultPredicate];
}

-(BOOL)searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchString:(NSString *)searchString {
    // Tells the table data source to reload when text changes
    [self filterContentForSearchText:searchString scope:
     [[self.searchDisplayController.searchBar scopeButtonTitles] objectAtIndex:[self.searchDisplayController.searchBar selectedScopeButtonIndex]]];
    // Return YES to cause the search result table view to be reloaded.
    return YES;
}

-(BOOL)searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchScope:(NSInteger)searchOption {
    // Tells the table data source to reload when scope bar selection changes
    [self filterContentForSearchText:self.searchDisplayController.searchBar.text scope:
     [[self.searchDisplayController.searchBar scopeButtonTitles] objectAtIndex:searchOption]];
    // Return YES to cause the search result table view to be reloaded.
    return YES;
}


- (id)initWithStyle:(UITableViewStyle)style
{
    self = [super initWithStyle:style];
    if (self) {
        // Custom initialization
    }
    return self;
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.tableData = [[NSMutableArray alloc] initWithCapacity:10];
    self.tableDataSections = [[NSMutableArray alloc] initWithCapacity:10];
    
    self.cityToFriendMappingG = [[NSMutableDictionary alloc] initWithCapacity:10];
    self.cityFriendDictionaryArrayG  = [[NSMutableArray alloc] initWithCapacity:10];
    
    [self getCityList];
    
    //connecting to facebook
    
    iCityAppDelegate *delegate = [[UIApplication sharedApplication] delegate];
    delegate.facebook.sessionDelegate = self;
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    if ([defaults objectForKey:@"FBAccessTokenKey"]
        && [defaults objectForKey:@"FBExpirationDateKey"]) {
        delegate.facebook.accessToken = [defaults objectForKey:@"FBAccessTokenKey"];
        NSLog(@"access token is : %@",delegate.facebook.accessToken);
        delegate.facebook.expirationDate = [defaults objectForKey:@"FBExpirationDateKey"];
    }
    
    if (![delegate.facebook isSessionValid])
    {
        
        NSArray *params = [[NSArray alloc] initWithObjects:@"user_location",@"friends_location",nil];
        
        if (![delegate.facebook isSessionValid])
        {
            [delegate.facebook authorize:params];
        }
        else
        {
            currentAction = FETCHING_FRIENDS;
            [self getFacebookLocations];
        }
        
        
    }
    else
    {
        currentAction = FETCHING_FRIENDS;
        [self getFacebookLocations];

    }

    
    
//    
//    NSLog(@"%@",cityDictionary);
//        NSLog(@"%@",cityList);

}

-(void)fbDidLogin
{
    iCityAppDelegate *delegate = [[UIApplication sharedApplication] delegate];
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    [defaults setObject:[delegate.facebook accessToken] forKey:@"FBAccessTokenKey"];
    [defaults setObject:[delegate.facebook expirationDate] forKey:@"FBExpirationDateKey"];
    [defaults synchronize];
    
    if ([delegate.facebook isSessionValid])
    {
        NSLog(@"already logged in");
        NSLog(@"checking permissons");
        
        currentAction = FETCHING_FRIENDS;
        
        [self getFacebookLocations];
        
    }

    
}

-(void)getFacebookLocations
{
    currentAction = FETCHING_FRIENDS;
    
    NSLog(@"calling getFacebookLocations");
    
    iCityAppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    
    
    
    NSString *userQuery = @"select uid, name , current_location, pic_square from user where uid in (select uid2 from friend where uid1=me()) order by name";
    
    
    NSMutableDictionary *queryParam =[NSMutableDictionary dictionaryWithObjectsAndKeys:userQuery, @"query", nil];
    
    [appDelegate.facebook requestWithMethodName:@"fql.query" andParams:queryParam andHttpMethod:@"POST" andDelegate:self];
    
}

-(void)request:(FBRequest *)request didLoad:(id)result
{
    
    iCityAppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];
    
    NSMutableDictionary *cityToFriendMapping = [[NSMutableDictionary alloc] initWithCapacity:AVERAGE_FRIENDS];
    NSMutableDictionary *cityGeoLocationMapping = [[NSMutableDictionary alloc] initWithCapacity:AVERAGE_FRIENDS];
    NSMutableDictionary *cityGeoNameMapping = [[NSMutableDictionary alloc] initWithCapacity:AVERAGE_FRIENDS];
    NSMutableDictionary *cityGeoPictureMapping = [[NSMutableDictionary alloc] initWithCapacity:AVERAGE_FRIENDS];
    NSMutableArray *cityFriendDictionaryArray = [[NSMutableArray alloc] initWithCapacity:AVERAGE_FRIENDS];

    
    if(currentAction == FETCHING_FRIENDS)
    {
        NSMutableString *locationQuery = [NSMutableString stringWithString:@"select page_id, pic_square, name , latitude , longitude from place where page_id in ( "];
        
        if(result)
        {
            NSArray *resultData = (NSArray *)result;
            NSLog(@"Fetched objects = %u",[resultData count]);
            //NSLog(@"result of friends = %@",resultData);
            
            if([resultData count]>0)
            {
                
                //creating FOMFriendDetails friend objects and
                for (NSDictionary *data in resultData)
                {
                    iCityFriendDetails *friend = [[iCityFriendDetails alloc] init];
                    
                    friend.name = [data objectForKey:@"name"];
                    friend.small_pic = [NSURL URLWithString:[data objectForKey:@"pic_square"]];
                    friend.userID = [data objectForKey:@"uid"];
                    
                    
                    
                                        
                    
                    //getting frineds current location details
                    NSDictionary *currentlocation = [(NSDictionary *)data objectForKey:@"current_location"];
                    if(! ((NSNull*)currentlocation == [NSNull null]) )
                    {
                        friend.currentCity = [currentlocation objectForKey:@"name"];
                        friend.cityID = [currentlocation objectForKey:@"id"];
                        
                        if([friend.currentCity length]>0 && friend.cityID !=nil )
                        {
                            //adding friend in array of respective dictionary of cityID
                            if([cityToFriendMapping objectForKey:friend.cityID] == nil)
                            {
                                NSMutableArray *friendArray = [[NSMutableArray alloc] initWithObjects:friend, nil];
                                [cityToFriendMapping setObject:friendArray forKey:friend.cityID];
                                
                            }
                            else
                            {
                                NSMutableArray *friendArray = [[cityToFriendMapping objectForKey:friend.cityID] mutableCopy];
                                [friendArray addObject:friend];
                                [cityToFriendMapping setObject:friendArray forKey:friend.cityID];
                                
                            }
                        }
                        else
                        {
//                            NSLog(@"%@",[friend.name stringByAppendingString:@" has no city ID %@"]);
                            
                        }
                    }
                    else
                    {
//                        NSLog(@"%@",[friend.name stringByAppendingString:@" has no city ID %@"]);
                        
                    }
                    
                }
                
            }
            
            //here we have dictionary of cityID and all friends into that city
            NSLog(@"Total cities: %u", [cityToFriendMapping count]);
            
            //            dispatch_async( dispatch_get_main_queue(), ^{
            //
            //
            //            });
            
            self.cityToFriendMappingG = [[NSMutableDictionary alloc] initWithDictionary:cityToFriendMapping];
            
            
            //finding cityID details like latitude and longitude
            NSArray *allLocationIDs = [cityToFriendMapping allKeys];
            
            if(allLocationIDs.count)
            {
                //generating query to fetch location data
                if([allLocationIDs count] > 1)
                {
                    [locationQuery appendFormat:@"%@",[allLocationIDs objectAtIndex:0]];
                    
                    for(int index=1; index < [allLocationIDs count]; index++)
                    {
                        [locationQuery appendFormat:@",%@",[allLocationIDs objectAtIndex:index]];
                        
                    }
                    [locationQuery appendString:@")"];
                    
                }
                else
                {
                    [locationQuery appendFormat:@"%@ )",[allLocationIDs objectAtIndex:0]];
                }
                
                
                NSMutableDictionary *queryParam =[NSMutableDictionary dictionaryWithObjectsAndKeys:locationQuery, @"query", nil];
                
                currentAction = FETCHING_CITIES;
                
                [appDelegate.facebook requestWithMethodName:@"fql.query" andParams:queryParam andHttpMethod:@"POST" andDelegate:self];
                
                
            }
            
            
        }
        
        
        
    }
    else if (currentAction == FETCHING_CITIES)
    {
        
        if(result)
        {
            NSArray *cityData = (NSArray *)result;
            
            
            //NSLog(@"%@",cityData);
            
            for(NSDictionary *place in cityData)
            {
                CLLocationDegrees latitude = [(NSString*)[place objectForKey:LATITUDE] doubleValue];
                CLLocationDegrees longitude = [(NSString*)[place objectForKey:LONGITUDE] doubleValue];
                //NSString *city= (NSString*)[place objectForKey:@"name"];
                CLLocationCoordinate2D location;
                location.latitude = latitude;
                location.longitude = longitude;
                
                NSData *locationIntoData = [NSData dataWithBytes:&location length:sizeof(location)];
                
                NSString *locationID = (NSString*)[place objectForKey:@"page_id"];
                NSURL *cityPic = [NSURL URLWithString:(NSString*)[place objectForKey:@"pic_square"]];
                
                NSString *cityName = (NSString*)[place objectForKey:@"name"];
                
                [cityGeoLocationMapping setObject:locationIntoData forKey:locationID];
                [cityGeoPictureMapping setObject:cityPic forKey:locationID];
                [cityGeoNameMapping setObject:cityName forKey:locationID];
                
                
                
                //NSLog(@"%@ is at %f, %f", city, latitude, longitude);
                
            }
            
            NSLog(@"%u cities fetched",[cityGeoLocationMapping count]);
            
            NSLog(@"%u friends are there",[self.cityToFriendMappingG count]);
            
            cityToFriendMapping = [[NSMutableDictionary alloc] initWithDictionary:self.cityToFriendMappingG];
            
            NSLog(@"%u friends in local array are there",[cityToFriendMapping count]);
            
            
            //mapping location to friends and geo locations and adding them into array
            
            for(NSString *cityID in [cityGeoLocationMapping allKeys])
            {
                NSMutableDictionary *friendWithLocation = [[NSMutableDictionary alloc] initWithCapacity:AVERAGE_FRIENDS];
                
                
                [friendWithLocation setObject:(NSData*)[cityGeoLocationMapping objectForKey:cityID] forKey:LOCATION_DATA];
                
                [friendWithLocation setObject:(NSArray*)[cityToFriendMapping objectForKey:cityID] forKey:FRIEND_DATA];
                
                [friendWithLocation setObject:cityID forKey:CITY_ID];
                [friendWithLocation setObject:(NSURL*)[cityGeoPictureMapping objectForKey:cityID] forKey:CITY_PIC];
                [friendWithLocation setObject:(NSURL*)[cityGeoNameMapping objectForKey:cityID] forKey:@"city_name"];
                
                
                [cityFriendDictionaryArray addObject:friendWithLocation];
                
            }
            
            self.cityFriendDictionaryArrayG = [[NSMutableArray alloc] initWithArray:cityFriendDictionaryArray];
            
            NSLog(@"%u is size of array",[cityFriendDictionaryArray count]);
            
            
            
        }
        
    }
    
    
    
}

-(void)fbDidNotLogin:(BOOL)cancelled
{
    NSLog(@"fb login failed");
}


#pragma mark - Table view data source

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{

    // Return the number of sections.
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{

    // Return the number of rows in the section.
    
    if(tableView == self.searchDisplayController.searchResultsTableView)
    {
        return [self.citySearchList count];
    }
    else
        return self.cityList.count;
    
    
    return self.cityList.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier = @"Cell";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    if (cell == nil) {
        
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
    }

    
    // Configure the cell...
    
    if(tableView == self.searchDisplayController.searchResultsTableView)
    {
        cell.textLabel.text = [self.citySearchList objectAtIndex:indexPath.row];
    }
    else
    {
        cell.textLabel.text = [self.cityList objectAtIndex:indexPath.row];
    }
    
    return cell;
}



- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *city;
    
    if(tableView == self.searchDisplayController.searchResultsTableView)
    {
//        NSLog(@"%@ selected", [self.citySearchList objectAtIndex:indexPath.row]);
        
        city = [[NSString alloc] initWithString:[self.citySearchList objectAtIndex:indexPath.row]];
        
    }
    else
    {
//        NSLog(@"%@ selected", [self.cityList objectAtIndex:indexPath.row]);
        
        city = [[NSString alloc] initWithString:[self.cityList objectAtIndex:indexPath.row]];
    }
    
    NSLog(@"selected city : %@",city);
    
    [self processCity:city];
    
    
}



-(void) getCityList
{
    //dispatch_async( dispatch_get_main_queue(), ^{
    
    
    NSData *cityData = [NSData dataWithContentsOfURL: [NSURL URLWithString:CITY_LIST_URL]];
    
    //NSLog(@"raw data : %@",cityData);
    
    NSError *error;
    NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:cityData options:kNilOptions error:&error];
    
    //    NSLog(@"parsed data : %@",jsonData);
    
    NSArray *lcityList = [[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"place"];
    
    //    NSLog(@"state list : %@",[[[[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"place"] objectAtIndex:0] objectForKey:@"name"]);
    
    NSMutableDictionary *lcityDictionary = [[NSMutableDictionary alloc] initWithCapacity:100];
    NSMutableArray *tmpcityList = [[NSMutableArray alloc] initWithCapacity:10];
    
    
    for(NSDictionary *city in lcityList)
    {
        //NSLog(@"%@ - %@",[city objectForKey:@"name"], [city objectForKey:@"woeid"]);
        
        [lcityDictionary setObject:[city objectForKey:@"woeid"] forKey:[city objectForKey:@"name"]];
        [tmpcityList addObject:[city objectForKey:@"name"]];
    }
    
    //NSLog(@"%@",cityDictionary);
    

    self.cityList = [NSArray arrayWithArray:[tmpcityList sortedArrayUsingComparator:^(NSString* a, NSString* b) {
        return [a compare:b options:NSNumericSearch];
    }]];
    
    self.cityDictionary = lcityDictionary;
//    self.cityList = tmpcityList;
    
    //});
    
}

-(void)processCity:(NSString *)city
{
    
    NSMutableArray *tableDataElement = [[NSMutableArray alloc] initWithCapacity:10];
    
    NSString *woeid = [cityDictionary objectForKey:city];

    NSLog(@"woeid is : %@",woeid);
    
    NSData *weatherData = [NSData dataWithContentsOfURL:[NSURL URLWithString:[WEATHER_URL stringByReplacingOccurrencesOfString:@"00000000" withString:woeid]]];
    
    
    NSError *error;
    NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:weatherData options:kNilOptions error:&error];
    
    
//    NSLog(@"parsed data : %@",jsonData);
    
    //NSArray *lcityList = [[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"place"];
    
    NSDictionary *item = [[[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"channel"] objectForKey:@"item"];
    
    NSString *title = [[[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"channel"] objectForKey:@"title"];
    
    [self.tableData removeAllObjects];
    [self.tableDataSections removeAllObjects];
    
    if(![title compare:@"Yahoo! Weather - Error"])
    {
        NSLog(@"weather info not found");
        [self.tableDataSections addObject:@"weather info"];
        [tableDataElement removeAllObjects];
        [tableDataElement addObject:@"not available"];
        [self.tableData addObject:[NSArray arrayWithArray:tableDataElement]];
    }
    else
    {
    
    
        NSUInteger temperature = [[[item objectForKey:@"condition"] objectForKey:@"temp"] integerValue];
        NSString *climate = [[item objectForKey:@"condition"] objectForKey:@"text"];

        temperature = (temperature-32)*5/9;
        
        [self.tableData removeAllObjects];
        [self.tableDataSections removeAllObjects];

        
        //adding today's data
        [tableDataElement removeAllObjects];
        [tableDataElement addObject:[NSString stringWithFormat:@"%u C", temperature]];
        [tableDataElement addObject:[NSString stringWithFormat:@"%@", climate]];
        
        [self.tableDataSections addObject:@"Today"];
        [self.tableData addObject:[[NSArray alloc] initWithArray:tableDataElement]];
        
        
        //weekly weather
        
        
        NSMutableArray *weekWeather = [[item objectForKey:@"forecast"] mutableCopy];
        [weekWeather removeObjectAtIndex:0];
    
        for(NSDictionary *weekday in weekWeather)
        {
    //        NSLog(@"high-low = %u - %u", [[weekday objectForKey:@"high"] integerValue], [[weekday objectForKey:@"low"] integerValue]);
            
            [tableDataElement removeAllObjects];
            [self.tableDataSections addObject:[weekday objectForKey:@"date"]];
            
            [tableDataElement addObject:[NSString stringWithFormat:@"%u - %u C", ([[weekday objectForKey:@"low"] integerValue]-32)*5/9, ([[weekday objectForKey:@"high"] integerValue]-32)*5/9]];
            
            [tableDataElement addObject:[NSString stringWithFormat:@"%@", [weekday objectForKey:@"text"]]];
            
            [self.tableData addObject:[NSArray arrayWithArray:tableDataElement]];
            NSLog(@"temp : %u and climate : %@", temperature, climate);

            
        }
    }
    
    //get cab info
    
    [self gatherCabInfo:city];
    
    //get facebook list
    
    [self gatherFacebookInfo:woeid];
    
//    NSLog(@"week info : %@", [item objectForKey:@"forecast"]);
    
    
    NSLog(@"sections : %@", self.tableDataSections);
//    NSLog(@"table data : %@",self.tableData);
    
    iCityShowCityInfo *cityInfo = [[iCityShowCityInfo alloc] init];
    
    cityInfo.rowArray = [NSArray arrayWithArray:self.tableData];
    cityInfo.sectionArray = [NSArray arrayWithArray:self.tableDataSections];
    cityInfo.title = city;
    
     cityInfo.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"Back" style:UIBarButtonItemStyleBordered target:self action:@selector(cancelthis)];
    
    self.navController = [[UINavigationController alloc] initWithRootViewController:cityInfo];
    
    self.navController.toolbarHidden = NO;
    self.navController.hidesBottomBarWhenPushed = YES;

    
    
    [self presentViewController:navController animated:YES completion:nil];
    
}

-(void)cancelthis
{
    NSLog(@"cancel in main view");
    [self.navController dismissViewControllerAnimated:YES completion:nil];
}

-(void)gatherFacebookInfo:(NSString*)woeid
{
    
    NSMutableArray *tableDataElement = [[NSMutableArray alloc] initWithCapacity:10];
    
    NSLog(@"url : %@", [NSURL URLWithString:[LOCATION_URL stringByReplacingOccurrencesOfString:@"00000000" withString:woeid]] );
    
    NSData *locationData = [NSData dataWithContentsOfURL:[NSURL URLWithString:[LOCATION_URL stringByReplacingOccurrencesOfString:@"00000000" withString:woeid]]];
    
    
    NSError *error;
    NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:locationData options:kNilOptions error:&error];
    
    //NSLog(@"parsed data for location: %@",jsonData);
    
    NSInteger longitude = [[[[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"Result"] objectForKey:@"longitude"] doubleValue]*1000;
    

    
    NSInteger latitude = [[[[[jsonData objectForKey:@"query"] objectForKey:@"results"] objectForKey:@"Result"] objectForKey:@"latitude"] doubleValue]*1000;
    
    NSLog(@"location : %ld %ld", (long)latitude  , (long)longitude);
    
    
//    NSLog(@"cityFriendDictionaryArrayG = %@", self.cityFriendDictionaryArrayG);
//    NSLog(@"cityToFriendMappingG = %@", self.cityToFriendMappingG);
    
    NSLog(@"cityFriendDictionaryArrayG count : %u", self.cityFriendDictionaryArrayG.count);
    
    [tableDataElement removeAllObjects];
    [self.tableDataSections addObject:@"Facebook friend nearby"];
    
    for(NSDictionary *tmpCity in self.cityFriendDictionaryArrayG)
    {
        NSData *locationDetails = [tmpCity objectForKey:LOCATION_DATA];

        CLLocationCoordinate2D location;
        [locationDetails getBytes:&location];
        
        NSInteger tmpLongitude = location.longitude*1000;
        NSInteger tmpLatitude = location.latitude*1000;
        
//        NSLog(@"%@ has %u %u, %u %u", [tmpCity objectForKey:@"city_name"], tmpLatitude, latitude, tmpLongitude, longitude);
        
        //NSLog(@"%u %u",tmpLatitude, latitude);
        
        if ( (tmpLatitude >= latitude-300 && tmpLatitude <= latitude+300) && (tmpLongitude >= longitude-500 && tmpLongitude <= longitude+500))
        {
//            NSLog(@"inside if");
            
            NSArray *friendData = [tmpCity objectForKey:FRIEND_DATA];
            
            for(iCityFriendDetails *friend in friendData)
            {
//                NSLog(@"%@ lives nearby", friend.name);
                
                UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:friend.small_pic]];
                
                NSDictionary *friendRow = [[NSDictionary alloc] initWithObjectsAndKeys:friend.name,@"name",image,@"small_pic", nil];
                
                [tableDataElement addObject:friendRow];
                
                
            }
            
            
        }
        
    }
    
    if(tableDataElement.count)
    {
        [self.tableData addObject:[NSArray arrayWithArray:tableDataElement]];
    }
    else
    {
        [self.tableData addObject:[NSArray arrayWithObject:@"No friend nearby"]];
    }
    
    
}

-(void)gatherCabInfo:(NSString*)city
{
    NSMutableArray *tableDataElement = [[NSMutableArray alloc] initWithCapacity:10];
    
    NSLog(@"cab url : %@", [NSURL URLWithString:[GOOGLE_API stringByAppendingFormat:@"%@+cabs",city]]);
    
    NSData *cabData = [NSData dataWithContentsOfURL:[NSURL URLWithString:[GOOGLE_API stringByAppendingFormat:@"%@+cabs",city]]];
    
    
    NSError *error;
    NSDictionary *jsonData = [NSJSONSerialization JSONObjectWithData:cabData options:kNilOptions error:&error];
    
    NSLog(@"cab data : %@", [[jsonData objectForKey:@"responseData"] objectForKey:@"results"]);
    
    NSArray *cabArray = [[jsonData objectForKey:@"responseData"] objectForKey:@"results"];
    
    for(NSDictionary *cab in cabArray)
    {
        [tableDataElement addObject:cab];
    }
    
    [self.tableDataSections addObject:@"Car Rentals available"];
    
    if(tableDataElement.count)
    {
        [self.tableData addObject:[NSArray arrayWithArray:tableDataElement]];
        
    }

}

@end

-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityFriendDetails.h
//  iCity
//
//  Created by Dinesh Salve on 07/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <CoreLocation/CoreLocation.h>


@interface iCityFriendDetails : NSObject

@property (strong, nonatomic) NSString *name;
@property (strong, nonatomic) NSURL *small_pic;
@property (strong, nonatomic) NSString *currentCity;
@property (strong, nonatomic) NSString *userID;
@property (strong, nonatomic) NSString *cityID;
@property (strong, nonatomic) UIImage *roundImage;



-(void)setLatitude:(CLLocationDegrees)newLatitude;
-(CLLocationDegrees)getLatitude;
-(void)setLongitude:(CLLocationDegrees)newLongitude;
-(CLLocationDegrees)getLongitude;


@end


-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityFriendDetails.m
//  iCity
//
//  Created by Dinesh Salve on 07/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import "iCityFriendDetails.h"

@implementation iCityFriendDetails

@synthesize name = _name;
@synthesize cityID = _cityID;
@synthesize currentCity = _currentCity;
@synthesize small_pic = _small_pic;
@synthesize userID = _userID;
@synthesize roundImage = _roundImage;



CLLocationDegrees latitude;
CLLocationDegrees longitude;

-(void)setLatitude:(CLLocationDegrees)newLatitude
{
    latitude = newLatitude;
    
}

-(CLLocationDegrees)getLatitude
{
    return latitude;
}


-(void)setLongitude:(CLLocationDegrees)newLongitude
{
    longitude = newLongitude;
    
}

-(CLLocationDegrees)getLongitude
{
    return longitude;
}

@end



-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityShowCityInfo.h
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import <UIKit/UIKit.h>

@interface iCityShowCityInfo : UITableViewController

@property (strong, nonatomic) NSArray *sectionArray;
@property (strong, nonatomic) NSArray *rowArray;

@end


-----------------------------------------------------------------------------------------------------------------------------------------------------

//
//  iCityShowCityInfo.m
//  iCity
//
//  Created by Dinesh Salve on 06/07/13.
//  Copyright (c) 2013 Dinesh salve. All rights reserved.
//

#import "iCityShowCityInfo.h"
#include <AddressBook/AddressBook.h>
#import <AddressBookUI/AddressBookUI.h>
#import "MLTableAlert.h"

@interface iCityShowCityInfo ()

@property (strong, nonatomic) NSMutableSet *phoneNumbers;
@property (strong, nonatomic) NSArray *phoneNumberListArray;
@property (strong, nonatomic) MLTableAlert *alert;

@end

@implementation iCityShowCityInfo



@synthesize sectionArray, rowArray, phoneNumbers, alert, phoneNumberListArray;

- (id)initWithStyle:(UITableViewStyle)style
{
    self = [super initWithStyle:style];
    if (self) {
        // Custom initialization
    }
    return self;
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.phoneNumbers = [[NSMutableSet alloc] initWithCapacity:10];

    // Uncomment the following line to preserve selection between presentations.
    // self.clearsSelectionOnViewWillAppear = NO;
 
    // Uncomment the following line to display an Edit button in the navigation bar for this view controller.
    // self.navigationItem.rightBarButtonItem = self.editButtonItem;
}


- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{

    // Return the number of sections.
    return self.sectionArray.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{

    // Return the number of rows in the section.
    return [[self.rowArray objectAtIndex:section] count];
}

-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
    return [self.sectionArray objectAtIndex:section];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier = @"Cell";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    if (cell == nil) {
        
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
    }
    
    // Configure the cell...
    
    if(![(NSString*)[self.sectionArray objectAtIndex:indexPath.section] compare:@"Facebook friend nearby"])
    {

        if([[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] isKindOfClass:[NSDictionary class]])
        {
            cell.textLabel.text = [[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] objectForKey:@"name"];
            cell.imageView.image = [[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] objectForKey:@"small_pic"];
        }
        else
        {
            cell.textLabel.text =  [[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row];
            cell.imageView.image = nil;
        }
        
        
    }
    else if(![(NSString*)[self.sectionArray objectAtIndex:indexPath.section] compare:@"Car Rentals available"])
    {
        cell.textLabel.text =  [[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] objectForKey:@"titleNoFormatting"];
        cell.imageView.image = nil;

    }
    else
    {
        cell.textLabel.text =  [[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row];
        cell.imageView.image = nil;
    }
    
    
    
    
    
    //NSLog(@"section : %u index : %u", indexPath.section,indexPath.row);
    
    return cell;
}


- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if(![(NSString*)[self.sectionArray objectAtIndex:indexPath.section] compare:@"Car Rentals available"])
    {
        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:[[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] objectForKey:@"url"]]];
        
    }
    else if(![(NSString*)[self.sectionArray objectAtIndex:indexPath.section] compare:@"Facebook friend nearby"])
    {
        
        [self.phoneNumbers removeAllObjects];
        
        NSLog(@"selected fb friend");
        
        if([[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] isKindOfClass:[NSDictionary class]])
        {
            NSLog(@"fetching contacts");
        
            NSString *name = [[[rowArray objectAtIndex:indexPath.section] objectAtIndex:indexPath.row] objectForKey:@"name"];
            NSLog(@"name from fb = %@",name);
            
            CFErrorRef * error = NULL;
            ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, error);
            
            ABAddressBookRequestAccessWithCompletion(addressBook, ^(bool granted, CFErrorRef error) {
                // ABAddressBook doesn't gaurantee execution of this block on main thread, but we want our callbacks to be
                dispatch_async(dispatch_get_main_queue(), ^{
                    if (!granted) {
                        
                        NSLog(@"no permission granted");
                        
                    } else {
                        
                        
                        
                        CFArrayRef allPeople =    ABAddressBookCopyArrayOfAllPeople( addressBook );
                        CFIndex nPeople = ABAddressBookGetPersonCount( addressBook );
                        
                        for ( int i = 0; i < nPeople; i++ )
                        {
                            ABRecordRef ref = CFArrayGetValueAtIndex( allPeople, i );
                            
                            ABMutableMultiValueRef multi = ABRecordCopyValue(ref, kABPersonPhoneProperty);

                            
                            NSString *contactName = (__bridge NSString *)(ABRecordCopyCompositeName(ref));
                            
                            if(![name compare:contactName])
                            {
                                
                                for (CFIndex i = 0; i < ABMultiValueGetCount(multi); i++)
                                    
                                {
                                    
                                    CFStringRef number = ABMultiValueCopyValueAtIndex(multi, i);
                                    
                                    [self.phoneNumbers addObject:(__bridge NSString*)number];

                                    NSLog(@"adding %@ for %@",(__bridge NSString*)number , contactName);
                                    
                                    CFRelease(number);
                                    
                                }
                            }
                            
                            CFRelease(multi);
                            
                        }
                        
                        CFRelease(allPeople);
                        
                        if(self.phoneNumbers.count)
                        {
                            self.phoneNumberListArray = [self.phoneNumbers allObjects];
                            
                            // create the alert
                            self.alert = [MLTableAlert tableAlertWithTitle:@"Choose the number" cancelButtonTitle:@"Cancel" numberOfRows:^NSInteger (NSInteger section)
                                          {
                                              return [self.phoneNumberListArray count];
                                          }
                                                                  andCells:^UITableViewCell* (MLTableAlert *anAlert, NSIndexPath *indexPath)
                                          {
                                              static NSString *CellIdentifier = @"CellIdentifier";
                                              UITableViewCell *cell = [anAlert.table dequeueReusableCellWithIdentifier:CellIdentifier];
                                              if (cell == nil)
                                                  cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
                                              
                                              cell.textLabel.text = [NSString stringWithFormat:@"%@", [self.phoneNumberListArray objectAtIndex:indexPath.row] ];
                                              
                                              return cell;
                                          }];
                            
                            // Setting custom alert height
                            self.alert.height = 250;
                            
                            [self.alert configureSelectionBlock:^(NSIndexPath *selectedIndex){
                                
                                NSString *tmpNumber = [self.phoneNumberListArray objectAtIndex:selectedIndex.row];
                                
                                NSURL *url=[NSURL URLWithString:[NSString stringWithFormat:@"%@%@", @"tel:", tmpNumber]];
                                
                                [[UIApplication sharedApplication]openURL:url];
                                
                                
                            } andCompletionBlock:^{
                                NSLog(@"No number selected");
                            }];
                            
                            // show the alert
                            [self.alert show];
                            
                            
                        }
                        else
                        {
                            NSLog(@"No numbers found");
                            
                            UIAlertView *noContactAlert = [[UIAlertView alloc] initWithTitle:@"Sorry!!" message:@"No phone number found" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles: nil];
                            
                            [noContactAlert show];
                            
                        }
                        
                        
                    }
                });
            });
            
            
            
                
    
        }
            
        
    }
        

}



@end
